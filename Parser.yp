%{
use 5.010;
use strict;
use warnings;

use POMP::Sub;
use POMP::Indent;
use POMP::Clause;

our @POMP_subs;
our %counts;
%}

%token IF

%token FOR
%token PARALLEL

%token SHARED
%token PRIVATE

%token CODE
%token UNHANDLED_CODE

%%

jobs: 
	| jobs job
	;
	
job:
	  UNHANDLED_CODE {
		  print $_[1];
	  }

	| directive clauses CODE {
		  my $directive   = $_[1];
		  my $clauses_ref = $_[2];
		  my $code        = $_[3];

		  ++$counts{$directive};

		  my $subname = $directive . $counts{$directive};
		  my $sub = POMP::Sub->new($subname, [], $code);

		  push @POMP_subs, $sub;

		  $sub->add_shared (@{$clauses_ref->{SHARED} });
		  $sub->add_private(@{$clauses_ref->{PRIVATE}});

		  if (my $cond = $clauses_ref->{IF}) {
			  print POMP::Clause::gen_if(
				  $cond,
				  $sub->gen_call($subname)
			  );
		  } else {
			  print $sub->gen_call($subname);
		  }
	  }
	;

directive:
	  PARALLEL { "parallel"; }
	| FOR      { "for"; }
	;

clauses:
	                  { {}; }
	| clauses clause  {
	      while (my ($key, $val) = each %{$_[2]}) {
			  $_[1]->{$key} = $val;
		  }
		  $_[1];
	  }
	;

clause:
	  IF      { { 'IF'      => $_[1] }; }
	| SHARED  {
		  my $tmp = $_[1];
		  $tmp =~ s/\s//;
	      return { 'SHARED'  => [ split(',', $tmp) ] };
	  }
	| PRIVATE {
		  my $tmp = $_[1];
		  $tmp =~ s/\s//;
		  return { 'PRIVATE' => [ split(',', $tmp) ] };
	  }
	;


%%

use Data::Dumper;

my $line = 0;
my $is_parsing = 0;  # set to true when a POMP command has been read. set to
                     # false when a corresponding #pomp_end has been read.

my $cond_re = qr/[\$%@]\w[\w\d]+/; # may be a variable only

sub lex {
	my $data = \$_[0]->YYData->{DATA};

	# remove leading spaces or line breaks when parsing a POMP command
	$$data =~ s/^[\s#]*// if ($is_parsing);

	# nothing else to read
	return ('', undef) unless (length $$data);

	## DIRECTIVES
	if ($$data =~ s/^#pomp_for//) {
		$is_parsing = 1;
		return ('FOR', undef);
	}

	if ($$data =~ s/^#pomp_parallel//) {
		$is_parsing = 1;
		return ('PARALLEL', undef);
	}

	## CODE
	if ($$data =~ s/
			^begin \s*   \n     # 'begin' is on a commented line, \n mandatory
			\s* (.*?)           # possible loop declaration
			\s* { [^\n]* \n     # keep indentation of the first line
			(.*?)               # get all the code within the block
			\s* } \s*           # remove useless spaces
			\n \s* \#pomp_end   # '#pomp_end' on a new line, possibly indented
		//sx && $is_parsing
	) {
		$is_parsing = 0;
		return ('CODE', POMP::Indent::reindent($2));
	}

	## CLAUSES
	if ($$data =~ s/^if \s* \( \s* ($cond_re) \s* \)//x) {
		return ('IF', $1);
	}

	if ($$data =~ s/^shared \s* \( \s* (.*?) \s* \)//x) {
		return ('SHARED', $1);
	}

	if ($$data =~ s/^private \s* \( \s* (.*?) \s* \)//x) {
		return ('PRIVATE', $1);
	}

	# end of recognized POMP langage
	$_[0]->YYError if ($is_parsing);

	$$data =~ s/(.*?)#/#/s;
	if ($1) {
		# skip code until next '#'
		return ('UNHANDLED_CODE', $1);
	} else {
		# no more '#', skip the rest of the file
		my $ret = $$data;
		$$data = "";
		return ('UNHANDLED_CODE', $ret);
	}
}

sub error {
	my $data = \$_[0]->YYData->{DATA};
	print "Error found: '" . ($$data =~ s/(.*?)\n/$1/rs) . "'\n";
}
