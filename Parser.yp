%{
use 5.010;
use strict;
use warnings;

use POMP::Sub;
use POMP::Indent;
use POMP::Clause;

our @POMP_subs;
our %counts;
%}

%token FOR
%token PARALLEL

%token IF
%token SHARED
%token PRIVATE
%token FIRSTPRIVATE
%token COMMA
%token VAR

%token CODE
%token CODE_START
%token UNHANDLED_CODE

%token PERL_FOREACH

%%

jobs: 
	| jobs job
	;
	
job:
	  UNHANDLED_CODE {
		  print $_[1];
	  }

	| directive clauses CODE_START declaration CODE {
		  my $directive   = $_[1];
		  my $clauses_ref = $_[2];
		  my $declaration = $_[4];
		  my $code        = $_[5];

		  # for directives must have a list declaration
		  if ($directive eq "for" && !defined $declaration) {
			  $_[0]->YYError;
		  }

		  # directive count
		  ++$counts{$directive};

		  my $subname = $directive . $counts{$directive};
		  my $sub = POMP::Sub->new($subname, $code);

		  push @POMP_subs, $sub;

		  $sub->add_shared      (@{$clauses_ref->{SHARED}      });
		  $sub->add_private     (@{$clauses_ref->{PRIVATE}     });
		  $sub->add_firstprivate(@{$clauses_ref->{FIRSTPRIVATE}});

		  if ($directive eq "for") {
			  $sub->add_foreach(@$declaration);
		  }

		  if (my $cond = $clauses_ref->{IF}) {
			  print POMP::Clause::gen_if(
				  $cond,
				  $sub->gen_call($subname)
			  );
		  } else {
			  print $sub->gen_call($subname);
		  }
	  }
	;

directive:
	  PARALLEL { "parallel"; }
	| FOR      { "for"; }
	;

clauses:
	                  { {}; }  # empty
	| clauses clause  {
	      while (my ($key, $val) = each %{$_[2]}) {
			  push @{ $_[1]->{$key} }, @$val if ($val);
		  }
		  $_[1];
	  }
	;

clause:
	  IF LPAREN VAR RPAREN {
		  { 'IF' => $_[3] };
	  }
	| SHARED LPAREN varlist RPAREN {
	      { 'SHARED'  => $_[3] };
	  }
	| PRIVATE LPAREN varlist RPAREN {
		  { 'PRIVATE' => $_[3] };
	  }
	| FIRSTPRIVATE LPAREN varlist RPAREN {
		  { 'FIRSTPRIVATE' => $_[3] };
	  }
	;

declaration:
	  # empty
	| PERL_FOREACH
	;

varlist:
	  # empty
	| vars
	;

vars:
	  vars COMMA VAR {
		  push @{ $_[1] }, $_[3];
		  $_[1];
	  }
	| VAR {
		  [ $_[1] ];
	  }
	;

%%

use Text::Balanced qw(extract_codeblock);

my $line = 0;
my $began = 0;
my $is_parsing = 0;  # set to true when a POMP command has been read. set to
                     # false when a corresponding #pomp_end has been read.

my $var_re    = qr/[\$%@]\w[\w\d]*/;
my $scalar_re = qr/\$\w[\w\d]*/;
my $list_re   = qr/@\w[\w\d]*/;
my $cond_re   = $var_re; # may be a variable only

sub lex {
	my $data = \$_[0]->YYData->{DATA};

	# sanity check
	die "Sanity check failed" if ($began && !$is_parsing);

	# remove leading spaces or line breaks when parsing a POMP command
	$$data =~ s/^[\s#]*// if ($is_parsing);

	# nothing else to read
	return ('', undef) unless (length $$data);

	## DIRECTIVES
	if ($$data =~ s/^#pomp_for//) {
		$is_parsing = 1;
		return ('FOR', undef);
	}

	if ($$data =~ s/^#pomp_parallel//) {
		$is_parsing = 1;
		return ('PARALLEL', undef);
	}

	## CODE
	if ($$data =~ s/^begin// && $is_parsing) {
		$began = 1;
		return ('CODE_START', undef);
	}

	if ($$data =~ s/
			^{ (?:[ \t]* \n)?   # Remove spaces after '{'
			                    # but keep indentation of the first line.
			(.*?)               # Get all the code within the block
			} \s*
			\n \s* \#pomp_end   # '#pomp_end' on a new line, possibly indented
		//sx && $began
	) {
		$began = 0;
		$is_parsing = 0;
		return ('CODE', POMP::Indent::reindent($1));
	}

	## Perl syntax subset
	if ($began) {
		# foreach(@list)
		#if ($$data =~ s/
		#		^for(?:each)? \s+           # for or foreach
		#		(?:my \s+ ($var_re))? \s*   # my $var
		#		\(($list_re)\)              # (list)
		#		//x
		#) {
		#	return ('PERL_FOREACH', [$1, $2]);
		#}

		# foreach(list expr)
		if ($$data =~ s/
				^for(?:each)? \s+           # for or foreach
				(?:my \s+ ($var_re))? \s*   # my $var
				\(/(/x
		) {
			my $list_expr = substr(extract_codeblock($$data, "("), 1, -1);
			return ('PERL_FOREACH', [$1, $list_expr]);
		}
	}

	## CLAUSES
	elsif ($is_parsing) {
		if ($$data =~ s/^if//) {
			return ('IF', undef);
		}

		if ($$data =~ s/^shared//) {
			return ('SHARED', undef);
		}

		if ($$data =~ s/^private//) {
			return ('PRIVATE', undef);
		}

		if ($$data =~ s/^firstprivate//) {
			return ('FIRSTPRIVATE', undef);
		}

		if ($$data =~ s/^,//) {
			return ('COMMA', undef);
		}

		if ($$data =~ s/^\(//) {
			return ('LPAREN', undef);
		}

		if ($$data =~ s/^\)//) {
			return ('RPAREN', undef);
		}

		if ($$data =~ s/^($var_re)//) {
			return ('VAR', $1);
		}
	}

	# end of recognized POMP langage
	$_[0]->YYError if ($is_parsing);

	$$data =~ s/(.*?[^#])#/#/s; # #pomp_* commands can be commented out too!
	if ($1) {
		# skip code until next '#'
		return ('UNHANDLED_CODE', $1);
	} else {
		# no more '#', skip the rest of the file
		my $ret = $$data;
		$$data = "";
		return ('UNHANDLED_CODE', $ret);
	}
}

sub error {
	my ($parser_ref, $error) = @_;
	my $data = \$parser_ref->YYData->{DATA};
	print "Error: $error\n" if ($error);
	print "Error Around: '" . ($$data =~ s/(.*?)\n/$1/rs) . "'\n";
}
