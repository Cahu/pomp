%{
use 5.010;
use strict;
use warnings;

use POMP::Sub;
use POMP::Indent;
use POMP::Clause;

our @POMP_subs;
our %counts;
%}

%token IF

%token FOR
%token PARALLEL

%token SHARED
%token PRIVATE

%token CODE
%token CODE_START
%token UNHANDLED_CODE

%token LPAREN
%token RPAREN
%token SEMICOLON

%token PERL_MY
%token PERL_FOR
%token PERL_FOREACH
%token PERL_EXPR

%%

jobs: 
	| jobs job
	;
	
job:
	  UNHANDLED_CODE {
		  print $_[1];
	  }

	| directive clauses CODE_START declaration CODE {
		  my $directive   = $_[1];
		  my $clauses_ref = $_[2];
		  my $code        = $_[5];

		  ++$counts{$directive};

		  my $subname = $directive . $counts{$directive};
		  my $sub = POMP::Sub->new($subname, $code);

		  push @POMP_subs, $sub;

		  $sub->add_shared (@{$clauses_ref->{SHARED} });
		  $sub->add_private(@{$clauses_ref->{PRIVATE}});

		  if (my $cond = $clauses_ref->{IF}) {
			  print POMP::Clause::gen_if(
				  $cond,
				  $sub->gen_call($subname)
			  );
		  } else {
			  print $sub->gen_call($subname);
		  }
	  }
	;

directive:
	  PARALLEL { "parallel"; }
	| FOR      { "for"; }
	;

clauses:
	                  { {}; }  # empty
	| clauses clause  {
	      while (my ($key, $val) = each %{$_[2]}) {
			  $_[1]->{$key} = $val;
		  }
		  $_[1];
	  }
	;

clause:
	  IF      { { 'IF' => $_[1] }; }
	| SHARED  {
		  my $tmp = $_[1];
		  $tmp =~ s/\s//g;
	      return { 'SHARED'  => [ split(',', $tmp) ] };
	  }
	| PRIVATE {
		  my $tmp = $_[1];
		  $tmp =~ s/\s//g;
		  return { 'PRIVATE' => [ split(',', $tmp) ] };
	  }
	;

declaration:
	  # empty
	| perl_foreach PERL_MY var LPAREN exprs RPAREN
	| PERL_FOR     LPAREN exprs SEMICOLON exprs SEMICOLON exprs RPAREN
	;

perl_foreach:
	  PERL_FOR
	| PERL_FOREACH
	;

exprs:
	| exprs PERL_EXPR
	;

%%

use Data::Dumper;

my $line = 0;
my $began = 0;
my $is_parsing = 0;  # set to true when a POMP command has been read. set to
                     # false when a corresponding #pomp_end has been read.

my $var_re  = qr/[\$%@]\w[\w\d]+/;
my $cond_re = $var_re; # may be a variable only

sub lex {
	my $data = \$_[0]->YYData->{DATA};

	# sanity check
	die "Sanity check failed" if ($began && !$is_parsing);

	# remove leading spaces or line breaks when parsing a POMP command
	$$data =~ s/^[\s#]*// if ($is_parsing);

	# nothing else to read
	return ('', undef) unless (length $$data);

	## DIRECTIVES
	if ($$data =~ s/^#pomp_for//) {
		$is_parsing = 1;
		return ('FOR', undef);
	}

	if ($$data =~ s/^#pomp_parallel//) {
		$is_parsing = 1;
		return ('PARALLEL', undef);
	}

	## CODE
	if ($$data =~ s/^begin// && $is_parsing) {
		$began = 1;
		return ('CODE_START', undef);
	}

	if ($$data =~ s/
			^{ [^\n]* \n         # keep indentation of the first line
			(.*?)               # get all the code within the block
			\s* } \s*           # remove useless spaces
			\n \s* \#pomp_end   # '#pomp_end' on a new line, possibly indented
		//sx && $began
	) {
		$began = 0;
		$is_parsing = 0;
		return ('CODE', POMP::Indent::reindent($1));
	}

	## Perl syntax subset
	if ($began) {
		if ($$data =~ s/^for//) {
			return ('PERL_FOR', undef);
		}

		if ($$data =~ s/^foreach//) {
			return ('PERL_FOREACH', undef);
		}

		if ($$data =~ s/^my//) {
			return ('PERL_MY', undef);
		}

		if ($$data =~ s/^\(//) {
			return ('LPAREN', undef);
		}

		if ($$data =~ s/^\)//) {
			return ('RPAREN', undef);
		}

		if ($$data =~ s/^;//) {
			return ('SEMICOLON', undef);
		}

		#if ($$data =~ s/^(.*?) //) {
		#	return ('PERL_EXPR', $1);
		#}
	}

	## CLAUSES
	elsif ($is_parsing) {
		if ($$data =~ s/^if \s* \( \s* ($cond_re) \s* \)//x) {
			return ('IF', $1);
		}

		if ($$data =~ s/^shared \s* \( \s* (.*?) \s* \)//x) {
			return ('SHARED', $1);
		}

		if ($$data =~ s/^private \s* \( \s* (.*?) \s* \)//x) {
			return ('PRIVATE', $1);
		}
	}

	# end of recognized POMP langage
	$_[0]->YYError if ($is_parsing);

	$$data =~ s/(.*?)#/#/s;
	if ($1) {
		# skip code until next '#'
		return ('UNHANDLED_CODE', $1);
	} else {
		# no more '#', skip the rest of the file
		my $ret = $$data;
		$$data = "";
		return ('UNHANDLED_CODE', $ret);
	}
}

sub error {
	my $data = \$_[0]->YYData->{DATA};
	print "Error found: '" . ($$data =~ s/(.*?)\n/$1/rs) . "'\n";
}
