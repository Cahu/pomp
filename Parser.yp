%{
use 5.010;
use strict;
use warnings;

use POMP::Sub;
use POMP::Indent;
use POMP::Clause;

our @POMP_subs;
our %counts;
%}

%token IF

%token FOR
%token PARALLEL

%token SHARED
%token PRIVATE

%token CODE
%token CODE_START
%token UNHANDLED_CODE

%token PERL_FOREACH

%%

jobs: 
	| jobs job
	;
	
job:
	  UNHANDLED_CODE {
		  print $_[1];
	  }

	| directive clauses CODE_START declaration CODE {
		  my $directive   = $_[1];
		  my $clauses_ref = $_[2];
		  my $declaration = $_[4];
		  my $code        = $_[5];

		  # for directives must have a list declaration
		  if ($directive eq "for" && !defined $declaration) {
			  $_[0]->YYError;
		  }

		  # directive count
		  ++$counts{$directive};

		  my $subname = $directive . $counts{$directive};
		  my $sub = POMP::Sub->new($subname, $code);

		  push @POMP_subs, $sub;

		  $sub->add_shared (@{$clauses_ref->{SHARED} });
		  $sub->add_private(@{$clauses_ref->{PRIVATE}});

		  if ($directive eq "for") {
			  $sub->add_foreach(@$declaration);
		  }

		  if (my $cond = $clauses_ref->{IF}) {
			  print POMP::Clause::gen_if(
				  $cond,
				  $sub->gen_call($subname)
			  );
		  } else {
			  print $sub->gen_call($subname);
		  }
	  }
	;

directive:
	  PARALLEL { "parallel"; }
	| FOR      { "for"; }
	;

clauses:
	                  { {}; }  # empty
	| clauses clause  {
	      while (my ($key, $val) = each %{$_[2]}) {
			  $_[1]->{$key} = $val;
		  }
		  $_[1];
	  }
	;

clause:
	  IF      { { 'IF' => $_[1] }; }
	| SHARED  {
		  my $tmp = $_[1];
		  $tmp =~ s/\s//g;
	      return { 'SHARED'  => [ split(',', $tmp) ] };
	  }
	| PRIVATE {
		  my $tmp = $_[1];
		  $tmp =~ s/\s//g;
		  return { 'PRIVATE' => [ split(',', $tmp) ] };
	  }
	;

declaration:
	  # empty
	| PERL_FOREACH { $_[1]; }
	;

%%

use Text::Balanced qw(extract_codeblock);

my $line = 0;
my $began = 0;
my $is_parsing = 0;  # set to true when a POMP command has been read. set to
                     # false when a corresponding #pomp_end has been read.

my $var_re    = qr/[\$%@]\w[\w\d]+/;
my $scalar_re = qr/\$\w[\w\d]+/;
my $list_re   = qr/@\w[\w\d]+/;
my $cond_re   = $var_re; # may be a variable only

sub lex {
	my $data = \$_[0]->YYData->{DATA};

	# sanity check
	die "Sanity check failed" if ($began && !$is_parsing);

	# remove leading spaces or line breaks when parsing a POMP command
	$$data =~ s/^[\s#]*// if ($is_parsing);

	# nothing else to read
	return ('', undef) unless (length $$data);

	## DIRECTIVES
	if ($$data =~ s/^#pomp_for//) {
		$is_parsing = 1;
		return ('FOR', undef);
	}

	if ($$data =~ s/^#pomp_parallel//) {
		$is_parsing = 1;
		return ('PARALLEL', undef);
	}

	## CODE
	if ($$data =~ s/^begin// && $is_parsing) {
		$began = 1;
		return ('CODE_START', undef);
	}

	if ($$data =~ s/
			^{ [^\n]* \n        # keep indentation of the first line
			(.*?)               # get all the code within the block
			} \s*
			\n \s* \#pomp_end   # '#pomp_end' on a new line, possibly indented
		//sx && $began
	) {
		$began = 0;
		$is_parsing = 0;
		return ('CODE', POMP::Indent::reindent($1));
	}

	## Perl syntax subset
	if ($began) {
		# foreach(@list)
		if ($$data =~ s/
				^for(?:each)? \s+           # for or foreach
				(?:my \s+ ($var_re))? \s*   # my $var
				\(($list_re)\)              # (list)
				//x
		) {
			return ('PERL_FOREACH', [$1, $2]);
		}
	}

	## CLAUSES
	elsif ($is_parsing) {
		if ($$data =~ s/^if \s* \( \s* ($cond_re) \s* \)//x) {
			return ('IF', $1);
		}

		if ($$data =~ s/^shared \s* \( \s* (.*?) \s* \)//x) {
			return ('SHARED', $1);
		}

		if ($$data =~ s/^private \s* \( \s* (.*?) \s* \)//x) {
			return ('PRIVATE', $1);
		}
	}

	# end of recognized POMP langage
	$_[0]->YYError if ($is_parsing);

	$$data =~ s/(.*?[^#])#/#/s; # #pomp_* commands can be commented out too!
	if ($1) {
		# skip code until next '#'
		return ('UNHANDLED_CODE', $1);
	} else {
		# no more '#', skip the rest of the file
		my $ret = $$data;
		$$data = "";
		return ('UNHANDLED_CODE', $ret);
	}
}

sub error {
	my ($parser_ref, $error) = @_;
	my $data = \$parser_ref->YYData->{DATA};
	print "Error: $error\n" if ($error);
	print "Error Around: '" . ($$data =~ s/(.*?)\n/$1/rs) . "'\n";
}
