%{
use 5.010;
use strict;
use warnings;

use POMP::Sub;

my @subs;
%}

%token IF

%token FOR
%token PARALLEL

%token LPAREN
%token RPAREN

%token SHARED
%token PRIVATE

%token CODE
%token UNHANDLED_CODE

%%

jobs: 
	| jobs job
	;
	
job:
	  UNHANDLED_CODE {
		  print $_[1];
	  }

	| directive clauses CODE {
		  my $directive   = $_[1];
		  my $clauses_ref = $_[2];
		  my $code        = $_[3];

		  say "Directive: $directive";
		  print "Clauses: ";
		  for my $c (@$clauses_ref) {
			  print $c if ($c);
		  }
		  say "";
		  say "CODE:";
		  POMP::Sub->new("machin", undef, $code)->print();
		  say "";
	  }
	;

directive:
	  PARALLEL { "parallel"; }
	| FOR      { "for"; }
	;

clauses:
	                  { undef; }
	| clauses clause  { [$_[2], @$_[1]]; }
	;

clause:
	  IF LPAREN expr RPAREN       { "if"; }
	| SHARED LPAREN list RPAREN   { "shared"; }
	| PRIVATE LPAREN list RPAREN  { "private"; }
	;

expr:
	;

list:
	;

%%

use Data::Dumper;

my $line = 0;
my $is_parsing = 0;

sub lex {
	my $data = \$_[0]->YYData->{DATA};

	# remove leading spaces
	$$data =~ s/^[ \n]+//;

	# nothing else to read
	return ('', undef) unless (length $$data);

	## DELIMITERS
	if ($$data =~ s/^\(//) {
		return ('LPAREN', undef) 
	}

	if ($$data =~ s/^\)//) {
		return ('RPAREN', undef) 
	}

	## DIRECTIVES
	if ($$data =~ s/^#pomp_for//) {
		$is_parsing = 1;
		return ('FOR', undef);
	}

	if ($$data =~ s/^#pomp_parallel//) {
		$is_parsing = 1;
		return ('PARALLEL', undef);
	}

	## CODE
	if ($$data =~ s/^begin\n(.*?\n)\s*#pomp_end//s && $is_parsing) {
		$is_parsing = 0;
		return ('CODE', $1);
	}

	## CLAUSES
	if ($$data =~ s/^if//) {
		return ('IF', undef);
	}

	if ($$data =~ s/^shared//) {
		return ('SHARED', undef);
	}

	if ($$data =~ s/^private//) {
		return ('PRIVATE', undef);
	}

	# end of recognized POMP langage
	die if ($is_parsing);

	$$data =~ s/(.*?)#/#/s;
	return ('UNHANDLED_CODE', $1);
}

sub error {
	print "Error\n";
}
